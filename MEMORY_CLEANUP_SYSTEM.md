# 记忆自动清理系统 v3.3.14

## ?? 功能概述

为了防止记忆系统中积累大量"死亡"记忆（activity极低但永不删除），我们实现了**双重清理机制**：

1. **方案1：Activity阈值清理** - 自动删除activity < 0.01的记忆
2. **方案3：容量限制强制执行** - 当层级满时，删除最低activity的记忆

---

## ?? 清理机制详解

### 方案1：Activity阈值清理

**触发时机**：每小时自动执行（随 `DecayActivity` 调用）

**清理条件**：
- `activity < 0.01`（认为已"死亡"）
- **不是**固定记忆（`isPinned = false`）
- **不是**用户编辑记忆（`isUserEdited = false`）

**影响范围**：
- ? **SCM（短期记忆）**：清理低activity记忆
- ? **ELS（中期记忆）**：清理低activity记忆
- ? **CLPA（长期记忆）**：永久保留，不清理

**示例**：
```
情况1：记忆 activity = 0.005
- isPinned = false
- isUserEdited = false
→ ? 被删除

情况2：记忆 activity = 0.005
- isPinned = true
→ ? 保留（用户固定）

情况3：记忆 activity = 0.005
- isUserEdited = true
→ ? 保留（用户编辑）
```

---

### 方案3：容量限制强制执行

**触发时机**：每小时自动执行（随 `DecayActivity` 调用）

**清理条件**：
- 层级记忆数量 > 最大容量
- 按 `activity` 升序排序
- 相同activity时，按 `timestamp` 升序（删除更旧的）
- **不是**固定记忆（`isPinned = false`）
- **不是**用户编辑记忆（`isUserEdited = false`）

**默认容量**：
- **SCM**：20条
- **ELS**：50条
- **CLPA**：无限制

**示例**：
```
SCM容量: 20
当前数量: 25
→ 删除5个最低activity的记忆

删除优先级（按activity从低到高）:
1. activity = 0.08, timestamp = 旧 → 删除
2. activity = 0.08, timestamp = 新 → 删除
3. activity = 0.10 → 删除
4. activity = 0.12 → 删除
5. activity = 0.15 → 删除
6. activity = 0.20 → 保留（已满足容量）
```

---

## ?? 配置参数

### Activity阈值
```csharp
const float ACTIVITY_THRESHOLD = 0.01f;
```
**说明**：低于此值的记忆被视为"死亡"，可以安全删除

### 衰减速率（Settings）
- `scmDecayRate`：短期记忆衰减速率
- `elsDecayRate`：中期记忆衰减速率
- `clpaDecayRate`：长期记忆衰减速率

### 容量限制（Settings）
- `maxActiveMemories`：超短期记忆上限（默认3）
- `maxSituationalMemories`：短期记忆上限（默认20）
- `maxEventLogMemories`：中期记忆上限（默认50）

---

## ?? 衰减示例

### 场景：短期记忆（SCM）衰减过程

假设 `scmDecayRate = 0.1`（每小时衰减10%）：

| 时间 | Activity值 | 状态 |
|------|-----------|------|
| 0小时 | 1.00 | 新建记忆 |
| 10小时 | 0.35 | 仍然活跃 |
| 20小时 | 0.12 | 开始衰弱 |
| 30小时 | 0.04 | 接近"死亡" |
| 40小时 | 0.015 | 接近阈值 |
| 45小时 | **0.008** | ? **被清理**（< 0.01）|

### 场景：用户编辑记忆（永久保留）

| 时间 | Activity值 | isUserEdited | 状态 |
|------|-----------|--------------|------|
| 0小时 | 1.00 | true | 用户创建 |
| 100小时 | 0.00001 | true | ? **不清理**（用户保护）|

---

## ??? 保护机制

### 1. 固定记忆（Pinned）
- 用户通过UI标记为"固定"的记忆
- **永不删除**，即使activity=0

### 2. 用户编辑记忆（UserEdited）
- 用户手动创建或编辑的记忆
- **永不删除**，即使activity=0

### 3. 长期记忆（CLPA）
- 归档层（Archive）的记忆
- **永久保留**，不受activity影响

---

## ?? 性能优化

### 清理频率
- **每小时执行一次**（随 `DecayActivity` 调用）
- 不会造成性能问题（轻量级操作）

### 日志输出
- 仅在 **DevMode** 下输出日志
- 普通游戏中不输出，避免日志污染

**日志示例**：
```
[Memory] 李四 cleaned up 3 SCM + 2 ELS memories (activity < 0.01)
[Memory] 李四 enforced limits: removed 5 SCM (max: 20) + 0 ELS (max: 50)
```

---

## ?? 测试验证

### 测试用例1：自然衰减清理
**步骤**：
1. 创建大量短期记忆
2. 等待40小时游戏时间
3. 检查记忆数量

**预期结果**：
- activity < 0.01的记忆被自动删除
- 固定/编辑记忆保留
- CLPA记忆完全保留

### 测试用例2：容量限制触发
**步骤**：
1. 创建25个短期记忆（超过20上限）
2. 等待1小时

**预期结果**：
- 自动删除5个最低activity的记忆
- 剩余20个记忆
- 固定/编辑记忆不受影响

### 测试用例3：保护机制验证
**步骤**：
1. 创建记忆并标记为"固定"
2. 等待100小时（activity衰减到极低）
3. 检查记忆是否存在

**预期结果**：
- 固定记忆仍然存在
- Activity可能=0.00001，但不被删除

---

## ?? 注意事项

### 1. 不可逆操作
- 清理后的记忆**无法恢复**
- 建议定期备份存档

### 2. 用户数据保护
- 所有用户手动创建/编辑的记忆**永不删除**
- 固定记忆**永不删除**

### 3. CLPA永久性
- 长期记忆（Archive）**永不清理**
- 即使activity=0，也保留

### 4. 设置建议
- 如果记忆删除过快，降低衰减速率
- 如果记忆积累过多，提高衰减速率或降低容量上限

---

## ?? 版本历史

### v3.3.14（当前版本）
- ? 添加activity阈值清理（方案1）
- ? 添加容量限制强制执行（方案3）
- ? 保护用户数据（固定/编辑记忆）
- ? CLPA永久保留策略

### 未来计划
- [ ] 可配置的activity阈值（Settings面板）
- [ ] 清理统计显示（UI面板）
- [ ] 清理历史记录（可选恢复）

---

## ?? 常见问题

### Q1: 为什么我的记忆被删除了？
**A**: 如果记忆的activity衰减到 < 0.01，且不是固定/编辑状态，会被自动清理。解决方法：
- 标记重要记忆为"固定"（UI中操作）
- 降低衰减速率（Settings）

### Q2: 如何防止重要记忆被删除？
**A**: 两种方法：
1. **固定记忆**：在记忆管理UI中标记为"固定"
2. **手动编辑**：编辑过的记忆自动受保护

### Q3: CLPA记忆会被删除吗？
**A**: **永不删除**。长期记忆（Archive）层永久保留。

### Q4: 容量上限可以调整吗？
**A**: 可以在Settings中调整：
- `maxSituationalMemories`
- `maxEventLogMemories`

---

**感谢使用RimTalk记忆系统！**
