# MainTabWindow_Memory 拆分 - 验证清单

## ? 已完成的工作

### 1. 部分类文件创建
- [x] MainTabWindow_Memory_TopBar.cs (145 行)
- [x] MainTabWindow_Memory_Controls.cs (376 行)
- [x] MainTabWindow_Memory_Timeline.cs (440 行)
- [x] MainTabWindow_Memory_Actions.cs (176 行)
- [x] MainTabWindow_Memory_ImportExport.cs (230 行)
- [x] MainTabWindow_Memory_Utilities.cs (210 行)
- [x] MainTabWindow_Memory_Helpers.cs (280 行 - 已存在)

### 2. 文档创建
- [x] 拆分报告 (Docs/拆分_MainTabWindow_Memory.md)
- [x] 验证清单 (Docs/拆分_验证清单.md)

---

## ? 待完成的工作

### 3. 主文件清理
- [ ] 打开 `Source/Memory/UI/MainTabWindow_Memory.cs`
- [ ] 删除已拆分到其他文件的方法：
  - [ ] DrawTopBar 相关方法 (已在 TopBar 文件)
  - [ ] DrawControlPanel 相关方法 (已在 Controls 文件)
  - [ ] DrawTimeline 相关方法 (已在 Timeline 文件)
  - [ ] SummarizeMemories 等操作方法 (已在 Actions 文件)
  - [ ] ExportMemories 等方法 (已在 ImportExport 文件)
  - [ ] GetFilteredMemories 等方法 (已在 Utilities 文件)
- [ ] 保留核心内容：
  - [ ] 字段定义
  - [ ] 构造函数
  - [ ] DoWindowContents (入口方法)
  - [ ] 类定义和命名空间
- [ ] 确认主文件约 100 行

### 4. 编译验证
- [ ] 运行编译命令：`dotnet build RimTalk-ExpandMemory.csproj`
- [ ] 检查是否有编译错误
- [ ] 修复任何 missing reference 错误

### 5. 功能测试
- [ ] 启动 RimWorld
- [ ] 加载测试存档
- [ ] 打开 Mind Stream 窗口
- [ ] 测试功能：
  - [ ] Pawn 选择器正常
  - [ ] 过滤器工作正常
  - [ ] 记忆卡片显示正常
  - [ ] 总结功能正常
  - [ ] 归档功能正常
  - [ ] 删除功能正常
  - [ ] 导出功能正常
  - [ ] 导入功能正常

### 6. Git 提交
- [ ] 查看变更：`git status`
- [ ] 添加文件：`git add Source/Memory/UI/MainTabWindow_Memory*.cs Docs/拆分*.md`
- [ ] 提交：`git commit -m "refactor: 拆分 MainTabWindow_Memory 为 7 个 partial class 文件"`
- [ ] 推送：`git push origin <branch-name>`

---

## ?? 主文件清理参考

### 需要保留的内容

```csharp
using UnityEngine;
using Verse;
using RimWorld;
using System.Collections.Generic;
using RimTalk.Memory;
using System;

namespace RimTalk.Memory.UI
{
    public partial class MainTabWindow_Memory : MainTabWindow
    {
        // ==================== Data & State ====================
        private Pawn selectedPawn = null;
        private FourLayerMemoryComp currentMemoryComp = null;
        
        private bool showAllHumanlikes = false;
        
        private HashSet<MemoryEntry> selectedMemories = new HashSet<MemoryEntry>();
        private MemoryEntry lastSelectedMemory = null;
        
        private bool isDragging = false;
        private Vector2 dragStartPos = Vector2.zero;
        private Vector2 dragCurrentPos = Vector2.zero;
        
        private Vector2 timelineScrollPosition = Vector2.zero;
        private MemoryType? filterType = null;
        
        private bool showABM = true;
        private bool showSCM = true;
        private bool showELS = true;
        private bool showCLPA = true;
        
        private List<MemoryEntry> cachedFilteredMemories;
        private bool filtersDirty = true;
        
        private const float TOP_BAR_HEIGHT = 50f;
        private const float CONTROL_PANEL_WIDTH = 220f;
        private const float SPACING = 10f;
        private const float CARD_WIDTH_FULL = 600f;
        private const float CARD_SPACING = 8f;
        
        private List<MemoryEntry> cachedMemories = new List<MemoryEntry>();
        private List<float> cachedCardHeights = new List<float>();
        private List<float> cachedCardYPositions = new List<float>();
        private float cachedTotalHeight = 0f;
        
        private int lastMemoryCount = -1;
        private bool lastShowABM;
        private bool lastShowSCM;
        private bool lastShowELS;
        private bool lastShowCLPA;
        private MemoryType? lastFilterType;
        private Pawn lastSelectedPawn;
        private int lastRefreshTick = -1;
        
        public override Vector2 RequestedTabSize => new Vector2(1200f, 700f);

        // ==================== Main Layout ====================
        
        public override void DoWindowContents(Rect inRect)
        {
            // Top Bar
            Rect topBarRect = new Rect(0f, 0f, inRect.width, TOP_BAR_HEIGHT);
            DrawTopBar(topBarRect);
            
            // Content area
            float contentY = TOP_BAR_HEIGHT + SPACING;
            float contentHeight = inRect.height - contentY;
            
            if (selectedPawn == null)
            {
                DrawNoPawnSelected(new Rect(0f, contentY, inRect.width, contentHeight));
                return;
            }
            
            var memoryComp = selectedPawn.TryGetComp<FourLayerMemoryComp>();
            if (memoryComp == null)
            {
                DrawNoMemoryComponent(new Rect(0f, contentY, inRect.width, contentHeight));
                return;
            }
            
            currentMemoryComp = memoryComp;
            
            CheckAndRefreshCache();
            
            // Left Control Panel
            Rect controlPanelRect = new Rect(0f, contentY, CONTROL_PANEL_WIDTH, contentHeight);
            DrawControlPanel(controlPanelRect);
            
            // Right Timeline
            float timelineX = CONTROL_PANEL_WIDTH + SPACING;
            float timelineWidth = inRect.width - timelineX;
            Rect timelineRect = new Rect(timelineX, contentY, timelineWidth, contentHeight);
            DrawTimeline(timelineRect);
            
            // Handle drag end
            if (Event.current.type == EventType.MouseUp && isDragging)
            {
                isDragging = false;
                Event.current.Use();
            }
        }
    }
}
```

### 需要删除的内容
- 所有 `DrawTopBar` 相关方法 → 已在 TopBar 文件
- 所有 `DrawControlPanel` 相关方法 → 已在 Controls 文件
- 所有 `DrawTimeline` 相关方法 → 已在 Timeline 文件
- 所有 `SummarizeMemories` 等方法 → 已在 Actions 文件
- 所有 `ExportMemories` 等方法 → 已在 ImportExport 文件
- 所有 `GetFilteredMemories` 等方法 → 已在 Utilities 文件

---

## ?? 注意事项

1. **不要删除字段定义** - 所有 private 字段必须保留在主文件中
2. **不要删除常量** - TOP_BAR_HEIGHT, CONTROL_PANEL_WIDTH 等必须保留
3. **保留 DoWindowContents** - 这是入口方法，必须在主文件中
4. **编译前备份** - 建议先提交当前状态到 Git

---

## ?? 常见问题

### 编译错误：找不到方法
**原因**: 方法被移动到其他文件但主文件还在调用  
**解决**: 检查该方法是否在某个 partial 文件中，partial class 会自动合并

### 编译错误：字段未定义
**原因**: 字段定义被误删除  
**解决**: 在主文件中恢复字段定义

### 运行时错误：NullReferenceException
**原因**: 字段未初始化  
**解决**: 检查构造函数和字段初始化代码

---

**最后更新**: 2025-01-XX  
**状态**: ? 所有部分类文件已创建，等待主文件清理
